/***
 From here and forward the lex files included have the
 sole purpose of interpreting tokens to send forward to
 bison. In the bison files, further work is done with
 defined grammar rules comprised of the tokens and
 their data values returned here.
***/

%{
#include <iostream>
#include <map>
#include <cstring>
#include <string>
#include <vector>
#include <algorithm>
#include <fstream>
#include "interpreter.tab.h"

#define YY_DECL extern "C" int yylex()

// read in larger tables at runtime
std::vector<std::string> readFile(std::string filePath){
    std::ifstream file(filePath);
    std::vector<std::string> ret;
    std::string word;
    while(file >> word){

        ret.push_back(word);
    }

    return ret;
}

// Lookup table for adjectives
std::vector<std::string> adjectives = readFile("../SimpsonsData/adjectives/28K adjectives.txt");


// Lookup table for adverbs
std::vector<std::string> adverbs = readFile("../SimpsonsData/adverbs/6K adverbs.txt");

// Lookup table for nouns
std::vector<std::string> nouns = readFile("../SimpsonsData/nouns/91K nouns.txt");


// Lookup table for verbs
std::vector<std::string> verbs = readFile("../SimpsonsData/verbs/31K verbs.txt");

// Lookup table for prepositions
std::vector<std::string> prepositions = {"about","above","across","ago","at","before","below","beside","by","for","from","in","into","of","off","on","onto","over","past","since","through","till","to","towards","under","until","with"};

// Lookup table for definite and indefinite articles
std::vector<std::string> articles = {"a","an","the"};

// Lookup table for pronouns
std::vector<std::string> pronouns = {"anyone","anything","everyone","everything","he","her","him","himself","i","it","itself","me","myself","nothing","one","she","someone","something","them","themselves","they","us","we","who","you"};

// Lookup table for contractions
std::vector<std::string> contractions = {"'tis","'twas","ain't","aren't","can't","could've","couldn't","didn't","doesn't","don't","hasn't","he'd","he'll","he's","how'd","how'll","how's","i'd","i'll","i'm","i've","isn't","it's","might've","must've","mustn't","shan't","she'd","she'll","she's","should've","shouldn't","that'll","that's","there's","they'd","they'll","they're","they've","wasn't","we'd","we'll","we're","weren't","what'd","what's","when","when's","where'd","where's","who'd","who'll","who's","why'd","why's","won't","would've","wouldn't","you'd","you'll","you're","you've"};

// Lookup tables for conjunctions
std::vector<std::string> conjunctions = {"and","but","for","nor","or","so","yet"};

// Implementation of binary search for std::vector as lookup tables are sorted :)
bool existsInVector(std::vector<std::string> &listToCheck, std::string wordToCheck){

    // need consistency so take input and turn to lower
    for (auto & c: wordToCheck)
        c = tolower(c);
    
	int left = 0;
	int right = listToCheck.size();
	int mid;

	while(left <= right){
		mid = (left + right) / 2;
		
		// get word to compare to
        if(mid == listToCheck.size())
            break;
		std::string word = listToCheck[mid];

		int direction = word.compare(wordToCheck);
		//std::cout << word << " " << direction << std::endl;
		if(direction > 0){
			// not in the upper half
			right = mid - 1;
		}
		else if(direction < 0){
			// not in the lower half
			left = mid + 1;
		}
		else{
			// Found the word
			return true;
		}
	}

	// didn't find the word..
	return false;

}

%}

/***
 Each rule returns a token identifier which is generated by bison
 and is defined in the interpreter.tab.h file. yylval is a union
 of possible data types defined in the bison file. We convert
 the value of the int or string matches and store it within the
 union structure.
***/
/*
*/




%%


[\n]                       {yylineno++; return EOL;}

[\|][A-Z \-\#0-9a-z]+[\|]       {yylval.sVal = strdup(yytext); std::cout << "CHARACTER" << std::endl; return CHARACTER; }

","                        {yylval.sVal = strdup(yytext); return COMMA; }

[?!\.]                     {yylval.sVal = strdup(yytext); return PUNCTUATION; }

[a-zA-z']+                {
                                // articles first..
                                bool isArticle = existsInVector(articles, yytext);

                                // then conjunctions..
                                bool isConjunction = existsInVector(conjunctions, yytext);

                                // then pronouns..
                                bool isPronoun = existsInVector(pronouns, yytext);

                                // then contractions
                                bool isContraction = existsInVector(contractions, yytext);

                                // then adjectives..
                                bool isAdjective = existsInVector(adjectives, yytext);

                                // then nouns..
                                bool isNoun = existsInVector(nouns, yytext);

                                // then verbs..
                                bool isVerb = existsInVector(verbs, yytext);

                                //then adverbs..
                                bool isAdverb = existsInVector(adverbs, yytext);

                                // prepositions last..
                                bool isPreposition = existsInVector(prepositions, yytext);
                                
                                
                                // copy string value into union
                                yylval.sVal = strdup(yytext);

                                if(isArticle){
                                    std::cout << "ARTICLE" << std::endl;
                                    std::cout << yytext << std::endl;
                                    return ARTICLE;
                                }
                                else if(isConjunction){
                                    std::cout << "CONJUNCTION" << std::endl;
                                    std::cout << yytext << std::endl;
                                    return CONJUNCTION;
                                }
                                else if(isPronoun){
                                    std::cout << "PRONOUN" << std::endl;
                                    std::cout << yytext << std::endl;
                                    return PRONOUN;
                                }
                                else if(isContraction){
                                    std::cout << "CONTRACTION" << std::endl;
                                    std::cout << yytext << std::endl;
                                    return CONTRACTION;
                                }
                                else if(isAdjective && isNoun){
                                    std::cout << "ADJECTIVENOUN" << std::endl;
                                    std::cout << yytext << std::endl;
                                    return ADJECTIVENOUN;
                                }
                                else if(isAdverb && isNoun){
                                    std::cout << "ADVERBNOUN" << std::endl;
                                    std::cout << yytext << std::endl;
                                    return ADVERBNOUN;
                                }
                                else if(isAdjective && isVerb){
                                    std::cout << "ADJECTIVEVERB" << std::endl;
                                    std::cout << yytext << std::endl;
                                    return ADJECTIVEVERB;
                                }
                                else if(isAdjective){
                                    std::cout << "ADJECTIVE" << std::endl;
                                    std::cout << yytext << std::endl;
                                    return ADJECTIVE;
                                }
                                else if(isNoun && isVerb){
                                    std::cout << "NOUNVERB" << std::endl;
                                    std::cout << yytext << std::endl;
                                    return NOUNVERB;
                                }
                                else if(isNoun){
                                    std::cout << "NOUN" << std::endl;
                                    std::cout << yytext << std::endl;
                                    return NOUN;
                                }
                                else if(isVerb){
                                    std::cout << "VERB" << std::endl;
                                    std::cout << yytext << std::endl;
                                    return VERB;
                                }
                                else if(isAdverb){
                                    std::cout << "ADVERB" << std::endl;
                                    std::cout << yytext << std::endl;
                                    return ADVERB;
                                }
                                else if(isPreposition){
                                    std::cout << "PREPOSITION" << std::endl;
                                    std::cout << yytext << std::endl;
                                    return PREPOSITION;
                                }
                                else{
                                    std::cout << "Error with word " << yytext << std::endl;
                                    exit(0);
                                }
                            }


%%
